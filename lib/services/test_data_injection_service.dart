import 'dart:convert';
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:sembast/sembast.dart' as sembast;
import 'package:sembast/sembast_io.dart';
import 'package:path_provider/path_provider.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import '../models/entry.dart';
import '../utils/date_formatter.dart';
import '../utils/animation_utils.dart';
import '../utils/firestore_paths.dart';

class TestDataInjectionService {
  sembast.Database? _db;
  sembast.StoreRef<String, Map<String, Object?>>? _store;
  late TickerProvider _vsync;

  TestDataInjectionService({required TickerProvider vsync}) {
    _vsync = vsync;
  }
  Future<void> _initDatabase() async {
    final Directory appDir = await getApplicationDocumentsDirectory();
    final String dbPath = '${appDir.path}/journal.db'; // Match JournalController's path
    _db = await databaseFactoryIo.openDatabase(dbPath);
    _store = sembast.stringMapStoreFactory.store('entries');
  }

  void dispose() {
    // Nothing to dispose in this implementation
  }
  Future<bool> injectFromJsonFile(String filePath) async {
    try {
      await _initDatabase();
      
      print('Reading test data from: $filePath');
      final file = File(filePath);
      
      if (!await file.exists()) {
        print('Error: File does not exist at $filePath');
        return false;
      }
      
      final jsonString = await file.readAsString();
      final jsonData = json.decode(jsonString);
      
      List<dynamic> entriesData;
      if (jsonData is Map && jsonData.containsKey('entries')) {
        entriesData = jsonData['entries'];
      } else if (jsonData is List) {
        entriesData = jsonData;
      } else {
        print('Error: Invalid JSON format');
        return false;
      }
      
      print('Found ${entriesData.length} entries to inject');
      
      int successCount = 0;
      
      for (int i = 0; i < entriesData.length; i++) {
        try {
          final entryData = entriesData[i] as Map<String, dynamic>;
          final rawDateTime = DateTime.parse(entryData['timestamp']);
          
          // Create Entry object from JSON data
          final entry = Entry(
            localId: null, // Will be auto-generated by database
            firestoreId: null,
            text: entryData['text'] ?? '',
            timestamp: DateFormatter.formatTime(rawDateTime),
            rawDateTime: rawDateTime,
            mood: entryData['mood'] ?? 'neutral',
            tags: List<String>.from(entryData['tags'] ?? []),
            wordCount: entryData['wordCount'] ?? 0,
            imageUrl: entryData['imageUrl'],
            isFavorite: entryData['isFavorite'] ?? false,
            isSynced: false, // Test data starts as unsynced
            localImagePath: entryData['localImagePath'],
            animController: AnimationUtils.createDefaultController(_vsync)..forward(),
          );
          
          // Convert entry to map using the same method as JournalController
          final entryMap = _entryToMap(entry);
          
          // Generate a unique localId
          final localId = DateTime.now().millisecondsSinceEpoch.toString() + '_$i';
          entryMap['localId'] = localId;
          
          // Save to database
          await _store!.record(localId).put(_db!, entryMap);
          successCount++;
          
          if ((i + 1) % 100 == 0) {
            print('Injected ${i + 1}/${entriesData.length} entries...');
          }
        } catch (e) {
          print('Error injecting entry $i: $e');
        }
      }
      
      print('Successfully injected $successCount/${entriesData.length} entries');
      return successCount > 0;
    } catch (e) {
      print('Error in injectFromJsonFile: $e');
      return false;
    }
  }
  Future<bool> flushDatabase() async {
    try {
      await _initDatabase();
      
      print('Clearing all entries from database...');
      await _store!.delete(_db!);
      
      print('Database cleared successfully');
      return true;
    } catch (e) {
      print('Error clearing database: $e');
      return false;
    }
  }
  Future<Map<String, dynamic>> getDatabaseStats() async {
    try {
      await _initDatabase();
      
      final records = await _store!.find(_db!);
      final totalEntries = records.length;
      
      int syncedEntries = 0;
      int unsyncedEntries = 0;
      DateTime? oldestDate;
      DateTime? newestDate;
      
      for (final record in records) {
        final entryMap = record.value;
        final isSynced = entryMap['isSynced'] as bool? ?? false;
        
        if (isSynced) {
          syncedEntries++;
        } else {
          unsyncedEntries++;
        }
        
        if (entryMap['timestamp'] != null) {
          final timestamp = DateTime.parse(entryMap['timestamp'] as String);
          
          if (oldestDate == null || timestamp.isBefore(oldestDate)) {
            oldestDate = timestamp;
          }
          
          if (newestDate == null || timestamp.isAfter(newestDate)) {
            newestDate = timestamp;
          }
        }
      }
      
      return {
        'totalEntries': totalEntries,
        'syncedEntries': syncedEntries,
        'unsyncedEntries': unsyncedEntries,
        'oldestEntry': oldestDate?.toIso8601String(),
        'newestEntry': newestDate?.toIso8601String(),
      };
    } catch (e) {
      print('Error getting database stats: $e');
      return {
        'totalEntries': 0,
        'syncedEntries': 0,
        'unsyncedEntries': 0,
        'oldestEntry': null,
        'newestEntry': null,
      };
    }
  }
  static Future<void> syncTestDataToFirebase() async {
    try {
      print('Starting Firebase sync for test data...');
        // Initialize database (same as other methods)
      final Directory appDir = await getApplicationDocumentsDirectory();
      final String dbPath = '${appDir.path}/journal.db'; // Match JournalController's path
      final database = await databaseFactoryIo.openDatabase(dbPath);
      final store = sembast.stringMapStoreFactory.store('entries');
      
      // Get all unsynced entries
      final finder = sembast.Finder(filter: sembast.Filter.equals('isSynced', false));
      final unsyncedRecords = await store.find(database, finder: finder);
      
      print('Found ${unsyncedRecords.length} unsynced entries to upload');
      
      if (unsyncedRecords.isEmpty) {
        print('No unsynced entries found');
        return;
      }
      
      int successCount = 0;
      
      for (final record in unsyncedRecords) {
        try {
          final entryMap = Map<String, dynamic>.from(record.value);
          
          // Prepare data for Firestore (exclude local-only fields)
          final firestoreData = {
            'text': entryMap['text'],
            'timestamp': entryMap['timestamp'],
            'mood': entryMap['mood'],
            'tags': entryMap['tags'],
            'wordCount': entryMap['wordCount'],
            'imageUrl': entryMap['imageUrl'],
            'isFavorite': entryMap['isFavorite'],
            'localImagePath': entryMap['localImagePath'],
          };
          
          // Upload to Firestore
          final docRef = await FirebaseFirestore.instance
              .collection(FirestorePaths.userEntriesPath())
              .add(firestoreData);
          
          if (docRef.id.isNotEmpty) {
            // Update local record with Firestore ID and mark as synced
            entryMap['firestoreId'] = docRef.id;
            entryMap['isSynced'] = true;
            
            await store.record(record.key).update(database, entryMap);
            successCount++;
            
            if (successCount % 50 == 0) {
              print('Synced $successCount/${unsyncedRecords.length} entries...');
            }
          }
        } catch (e) {
          print('Error syncing entry ${record.key}: $e');
        }
      }
      
      await database.close();
      print('Successfully synced $successCount/${unsyncedRecords.length} entries to Firebase');
    } catch (e) {
      print('Error in syncTestDataToFirebase: $e');
      throw e;
    }
  }
  Map<String, Object?> _entryToMap(Entry entry) {
    return {
      'localId': entry.localId,
      'firestoreId': entry.firestoreId,
      'text': entry.text,
      'timestamp': entry.rawDateTime.toIso8601String(),
      'mood': entry.mood,
      'tags': entry.tags,
      'wordCount': entry.wordCount,
      'imageUrl': entry.imageUrl,
      'isFavorite': entry.isFavorite,
      'isSynced': entry.isSynced,
      'localImagePath': entry.localImagePath,
    };
  }
}
